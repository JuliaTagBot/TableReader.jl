<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TableReader.jl · TableReader.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TableReader.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>TableReader.jl</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Usage-1">Usage</a></li><li><a class="toctext" href="#Design-notes-1">Design notes</a></li><li><a class="toctext" href="#Limitations-1">Limitations</a></li></ul></li><li><a class="toctext" href="reference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>TableReader.jl</a></li></ul><a class="edit-page" href="https://github.com/bicycle1885/TableReader.jl/blob/master/README.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>TableReader.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="TableReader.jl-1" href="#TableReader.jl-1">TableReader.jl</a></h1><p><a href="https://travis-ci.com/bicycle1885/TableReader.jl"><img src="https://travis-ci.com/bicycle1885/TableReader.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://codecov.io/gh/bicycle1885/TableReader.jl"><img src="https://codecov.io/gh/bicycle1885/TableReader.jl/branch/master/graph/badge.svg" alt="Codecov"/></a></p><p>TableReader.jl does not waste your time.</p><p>Features:</p><ul><li>Carefully optimized for speed.</li><li>Transparently decompresses gzip, xz, and zstd data.</li><li>Read data from a local file, a remote file, or a running process.</li></ul><p>Here is a quick benchmark of start-up time:</p><pre><code class="language-none">~/w/TableReader (master|…) $ julia
               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type &quot;?&quot; for help, &quot;]?&quot; for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.1.0 (2019-01-21)
 _/ |\__&#39;_|_|_|\__&#39;_|  |  Official https://julialang.org/ release
|__/                   |

julia&gt; using TableReader

julia&gt; @time readcsv(&quot;data/iris.csv&quot;);  # start-up time
  2.301008 seconds (2.80 M allocations: 139.657 MiB, 1.82% gc time)

~/w/TableReader (master|…) $ julia -q
julia&gt; using CSV, DataFrames

julia&gt; @time DataFrame(CSV.File(&quot;data/iris.csv&quot;));  # start-up time
  7.443172 seconds (33.26 M allocations: 1.389 GiB, 9.05% gc time)

~/w/TableReader (master|…) $ julia -q
julia&gt; using CSVFiles, DataFrames

julia&gt; @time DataFrame(load(&quot;data/iris.csv&quot;));  # start-up time
 12.578236 seconds (47.81 M allocations: 2.217 GiB, 9.87% gc time)</code></pre><p>And the parsing throughput of TableReader.jl is often ~1.5-3.0 times faster than those of pandas and other Julia packages. See <a href="https://discourse.julialang.org/t/ann-tablereader-jl-a-fast-and-simple-csv-parser/22335">this post</a> for more selling points.</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>Start a new session by the <code>julia</code> command, hit the &lt;kbd&gt;]&lt;/kbd&gt; key to change the mode, and run <code>add TableReader</code> in the <code>pkg&gt;</code> prompt.</p><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><pre><code class="language-julia"># This takes the three functions into the current scope:
#   - readdlm
#   - readcsv
#   - readtsv
using TableReader

# Read a CSV file and return a DataFrame object.
dataframe = readcsv(&quot;somefile.csv&quot;)

# Read gzip/xz/zstd compressed files.
dataframe = readcsv(&quot;somefile.csv.gz&quot;)

# Read a remote file as downloading.
dataframe = readcsv(&quot;https://example.com/somefile.csv&quot;)

# Read stdout from a process.
dataframe = readcsv(`unzip -p data.zip somefile.csv`)</code></pre><p>The following parameters are available:</p><ul><li><code>delim</code>: specify the delimiter character</li><li><code>quot</code>: specify the quotation character</li><li><code>trim</code>: trim space around fields</li><li><code>lzstring</code>: parse excess leading zeros as strings</li><li><code>skip</code>: skip the leading lines</li><li><code>skipblank</code>: skip blank lines</li><li><code>comment</code>: specify the leading sequence of comment lines</li><li><code>colnames</code>: set the column names</li><li><code>normalizenames</code>:  &quot;normalize&quot; column names into valid Julia (DataFrame) identifier symbols</li><li><code>hasheader</code>: notify the parser the existence of a header</li><li><code>chunkbits</code>: set the size of a chunk</li></ul><p>See the docstring of <code>readdlm</code> for more details.</p><h2><a class="nav-anchor" id="Design-notes-1" href="#Design-notes-1">Design notes</a></h2><p>TableReader.jl is aimed at users who want to keep the easy things easy.  It exports three functions: <code>readdlm</code>, <code>readcsv</code>, and <code>readtsv</code>. <code>readdlm</code> is at the core of the package, and the other two functions are a thin wrapper that calls <code>readdlm</code> with some default parameters; <code>readcsv</code> is for CSV files and <code>readtsv</code> is for TSV files. These functions returns a data frame of DataFrames.jl. No other functions except the three are exported from this package.</p><p>The three functions takes an object as the source of tabular data to read. It may be a filename, a URL string, a command, or any kind of I/O objects.  For example, the following examples will work as you expect:</p><pre><code class="language-julia">readcsv(&quot;path/to/filename.csv&quot;)
readcsv(&quot;https://example.com/path/to/filename.csv&quot;)
readcsv(`unzip -p path/to/dataset.zip filename.csv`)
readcsv(IOBuffer(some_csv_data))</code></pre><p>In addition, the functions guess the file format from the magic bytes if any. Currently, plain text, gzip, xz, and zstd are detectable. These file formats are transparently decompressed if required and thus the user does not need to decompress a file in advance.</p><p>Column data types are guessed from the data. Currently, integers (<code>Int</code>), floating-point numbers (<code>Float64</code>), boolean values (<code>Bool</code>), dates (<code>Date</code>), datetimes (<code>DateTime</code>), missing values (<code>Missing</code>), and strings (<code>String</code>) are supported. If empty fields (i.e., two consective delimiters, or a delimiter and a newline) or &quot;NA&quot; are found, they are interpreted as missing values. Such a column is converted to a vector of <code>Vector{Union{T,Missing}}</code>, where <code>T</code> refers to a data type guessed from non-missing values.</p><p>To reduce memory usage, the parser of this package reads data chunk by chunk. The default chunk size is 1 MiB, and data types are guessed using the bufferred data in the first chunk. Although this strategy works in most cases, you may encounter situation where most values in a column look like integers but only few are not parsable as integers. If you are bad luck, such anomalies are not in the first chunk and type guessing may fail. Consequently, parsing will also fail when the parser sees the first occurrence.  To avoid the problem, you can turn off the chunking behavior by setting the <code>chunkbits</code> parameter to zero. For example, <code>readcsv(&quot;somefile.csv&quot;, chunkbits = 0)</code> will read the whole file into memory as a single large chunk and the data types of columns are guessed from all of the fields.  While this requires more memories, you will never see parsing error due to the failure of type guessing.</p><h2><a class="nav-anchor" id="Limitations-1" href="#Limitations-1">Limitations</a></h2><p>The tokenizer cannot handle extremely long fields in a data file. The length of a token is encoded using 24-bit integer, and therefore a cell that is longer than or equal to 16 MiB will result in parsing failure. This is not likely to happen, but please be careful if, for example, a column contains long strings. Also, the size of a chunk is limited up to 64 GiB; you cannot disable chunking if the data size is larger than that.</p><p>[transcodingstreams-url]: https://github.com/bicycle1885/TranscodingStreams.jl</p><footer><hr/><a class="next" href="reference/"><span class="direction">Next</span><span class="title">Reference</span></a></footer></article></body></html>
