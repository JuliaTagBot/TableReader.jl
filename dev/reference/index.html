<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · TableReader.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TableReader.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">TableReader.jl</a></li><li class="current"><a class="toctext" href>Reference</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Reference</a></li></ul><a class="edit-page" href="https://github.com/bicycle1885/TableReader.jl/blob/master/docs/src/reference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TableReader.readcsv" href="#TableReader.readcsv"><code>TableReader.readcsv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">readcsv(filename, command, or IO object; delim = &#39;,&#39;, &lt;keyword arguments&gt;)</code></pre><p>Read a CSV (comma-separated values) text file.</p><p>This function is the same as <a href="#TableReader.readdlm"><code>readdlm</code></a> but with <code>delim = &#39;,&#39;</code>. See <code>readdlm</code> for details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TableReader.jl/blob/35c61dd38d5a0d74dbfa92327881dd66df3a7cec/src/TableReader.jl#L215-L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TableReader.readtsv" href="#TableReader.readtsv"><code>TableReader.readtsv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">readtsv(filename, command, or IO object; delim = &#39;\t&#39;, &lt;keyword arguments&gt;)</code></pre><p>Read a TSV (tab-separated values) text file.</p><p>This function is the same as <a href="#TableReader.readdlm"><code>readdlm</code></a> but with <code>delim = &#39;\t&#39;</code>. See <code>readdlm</code> for details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TableReader.jl/blob/35c61dd38d5a0d74dbfa92327881dd66df3a7cec/src/TableReader.jl#L225-L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TableReader.readdlm" href="#TableReader.readdlm"><code>TableReader.readdlm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">readdlm(filename, command, or IO object;
        delim,
        quot = &#39;&quot;&#39;,
        trim = true,
        lzstring = true,
        skip = 0,
        skipblank = true,
        colnames = nothing,
        normalizenames = false,
        hasheader = (colnames === nothing),
        chunkbits = 20  #= 1 MiB =#)</code></pre><p>Read a character delimited text file.</p><p><a href="#TableReader.readcsv"><code>readcsv</code></a> and <a href="#TableReader.readtsv"><code>readtsv</code></a> call this function behind. To read a CSV or TSV file, consider to use these dedicated function instead.</p><p><strong>Data source</strong></p><p>The first (and the only positional) argument specifies the source to read data from there.</p><p>If the argument is a string, it is considered as a local file name or the URL of a remote file. If the name matches with <code>r&quot;^\w+://.*&quot;</code> in regular expression, it is handled as a URL. For example, <code>&quot;https://example.com/path/to/file.csv&quot;</code> is regarded as a URL and its content is streamed using the <code>curl</code> command.</p><p>If the argument is a command object, it is considered as a source whose standard output is text data to read. For example, <code>unzip -p path/to/file.zip somefile.csv</code> can be used to extract a file from a zipped archive. It is also possible to pipeline several commands using <code>pipeline</code>.</p><p>If the arguments is an object of the <code>IO</code> type, it is considered as a direct data source. The content is read using <code>read</code> or other similar functions. For example, passing <code>IOBuffer(text)</code> makes it possible to read data from the raw text object.</p><p>The data source is transparently decompressed if the compression format is detectable. Currently, gzip, zstd, and xz are supported. The format is detected by the magic bytes of the stream header, and therefore other information such as file names does not affect the detection.</p><p><strong>Parser parameters</strong></p><p><code>delim</code> specifies the field delimiter in a line.  This cannot be the same character as <code>quot</code>.  Currently, the following delimiters are allowed: &#39;\t&#39;, &#39; &#39;, &#39;!&#39;, &#39;&quot;&#39;, &#39;#&#39;, &#39;$&#39;, &#39;%&#39;, &#39;&amp;&#39;, &#39;\&#39;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;*&#39;, &#39;+&#39;, &#39;,&#39;, &#39;-&#39;, &#39;.&#39;, &#39;/&#39;, &#39;:&#39;, &#39;;&#39;, &#39;&lt;&#39;, &#39;=&#39;, &#39;&gt;&#39;, &#39;?&#39;, &#39;@&#39;, &#39;[&#39;, &#39;\&#39;, &#39;]&#39;, &#39;^&#39;, &#39;_&#39;, &#39;`&#39;, &#39;{&#39;, &#39;|&#39;, &#39;}&#39;, &#39;~&#39;.</p><p><code>quot</code> specifies the quotation character to enclose a field. This cannot be the same character as <code>delim</code>. Currently, the following quotation characters are allowed: &#39; &#39;, &#39;!&#39;, &#39;&quot;&#39;, &#39;#&#39;, &#39;$&#39;, &#39;%&#39;, &#39;&amp;&#39;, &#39;\&#39;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;*&#39;, &#39;+&#39;, &#39;,&#39;, &#39;-&#39;, &#39;.&#39;, &#39;/&#39;, &#39;:&#39;, &#39;;&#39;, &#39;&lt;&#39;, &#39;=&#39;, &#39;&gt;&#39;, &#39;?&#39;, &#39;@&#39;, &#39;[&#39;, &#39;\&#39;, &#39;]&#39;, &#39;^&#39;, &#39;_&#39;, &#39;`&#39;, &#39;{&#39;, &#39;|&#39;, &#39;}&#39;, &#39;~&#39;.</p><p><code>trim</code> specifies whether the parser trims space (0x20) characters around a field. If <code>trim</code> is true, <code>delim</code> and <code>quot</code> cannot be a space character.</p><p><code>lzstring</code> specifies whether fields with excess leading zeros are treated as strings.  If <code>lzstring</code> is true, fields such as &quot;0003&quot; will be interpreted as strings instead of integers.</p><p><code>skip</code> specifies the number of lines to skip before reading data.  The next line just after the skipped lines is considered as a header line if the <code>colnames</code> parameter is not specified.</p><p><code>skipblank</code> specifies whether the parser ignores blank lines. If <code>skipblank</code> is false, encountering a blank line throws an exception.</p><p><code>comment</code> specifies the leading sequence of comment lines. If it is a non-empty string, text lines that start with the sequence will be skipped as comments. The default value (empty string) does not skip any lines as comments.</p><p><strong>Column names</strong></p><p><code>colnames</code> specifies the column names. If <code>colnames</code> is <code>nothing</code> (default), the column names are read from the first line just after skipping lines specified by <code>skip</code> (no lines are skipped by default). Any iterable object is allowed.</p><p><code>normalizenames</code> uses &#39;safe&#39; names for Julia symbols used in DataFrames. If <code>normalizenames</code> is <code>false</code> (default), the column names will be the same as the source file using basic parsing. If <code>normalizenames</code> is <code>true</code> then reserved words and characters will be removed/replaced in the column names.</p><p><code>hasheader</code> specified whether the data has a header line or not. The default value is <code>colnames === nothing</code> and thus the parser assumes there is a header if and only if no column names are specified.</p><p>The following table summarizes the behavior of the <code>colnames</code> and <code>hasheader</code> parameters.</p><table><tr><th style="text-align: left"><code>colnames</code></th><th style="text-align: left"><code>hasheader</code></th><th style="text-align: left">column names</th></tr><tr><td style="text-align: left"><code>nothing</code></td><td style="text-align: left"><code>true</code></td><td style="text-align: left">taken from the header (default)</td></tr><tr><td style="text-align: left"><code>nothing</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">automatically generated (X1, X2, ...)</td></tr><tr><td style="text-align: left">specified</td><td style="text-align: left"><code>true</code></td><td style="text-align: left">taken from <code>colnames</code> (the header line is skipped)</td></tr><tr><td style="text-align: left">specified</td><td style="text-align: left"><code>false</code></td><td style="text-align: left">taken from <code>colnames</code></td></tr></table><p>If unnamed columns are found in the header, they are renamed to <code>UNNAMED_{j}</code> for ease of access, where <code>{j}</code> is replaced by the column number. If the number of header columns in a file is less than the number of data columns by one, a column name <code>UNNAMED_0</code> will be inserted into the column names as the first column.  This is useful to read files written by the <code>write.table</code> function of R with <code>row.names = TRUE</code>.</p><p><strong>Data types</strong></p><p>Integers, floating-point numbers, boolean values, dates, datetimes, missings, and strings are automatically detected and converted from the text data.  The following list is the summary of the corresponding data types of Julia and the text formats described in the regular expression:</p><ul><li>Integer (<code>Int</code>): <code>[-+]?\d+</code></li><li>Float (<code>Float64</code>): <code>[-+]?\d*\.?\d+</code>, <code>[-+]?\d*\.?\d+([eE][-+]?\d+)?</code>,                    <code>[-+]?NaN</code> or <code>[-+]?Inf(inity)?</code> (case-insensitive)</li><li>Bool (<code>Bool</code>): <code>t(rue)?</code> or <code>f(alse)?</code> (case-insensitive)</li><li>Date (<code>Dates.Date</code>): <code>\d{4}-\d{2}-\d{2}</code></li><li>Datetime (<code>Dates.DateTime</code>): <code>\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}(\.\d+)?</code></li><li>Missing (<code>Missing</code>): empty field or <code>NA</code> (case-sensitive)</li><li>String (<code>String</code>): otherwise</li></ul><p>Integers and floats have some overlap. The parser precedes integers over floats.  That means, if all values in a column are parsable as integers and floats, they are parsed as integers instead of floats; otherwise, they are parsed as floats. Similarly, all the types have higher precedence than strings.</p><p>The parser parameter <code>lzstring</code> affects interpretation of numbers. If <code>lzstring</code> is true, numbers with excess leading zeros (e.g., &quot;0001&quot;, &quot;00.1&quot;) are interpreted as strings. Fields without excess leading zeros (e.g., &quot;0&quot;, &quot;0.1&quot;) are interepreted as numbers regardless of this parameter.</p><p><strong>Parsing behavior</strong></p><p>The only supported text encoding of a file is UTF-8, which is the default character encoding scheme of many functions in Julia.  If you need to read text encoded other than UTF-8, it is required to wrap the data stream with an encoding conversion tool such as the <code>iconv</code> command or StringEncodings.jl.</p><pre><code class="language-julia"># Convert text encoding from Shift JIS (Japanese) to UTF8.
readcsv(`iconv -f sjis -t utf8 somefile.csv`)</code></pre><p>A text file will be read chunk by chunk to save memory. The chunk size is specified by the <code>chunkbits</code> parameter, which is the base two logarithm of actual chunk size.  The default value is 20 (i.e., 2^20 bytes = 1 MiB).  The data type of each column is guessed from the values in the first chunk.  If <code>chunkbits</code> is set to zero, it disables chunking and the data types are guessed from all rows. The chunk size will be automatically expanded when it is required to store long lines.</p><p>A chunk cannot be larger than 64 GiB and a field cannot be longer than 16 MiB. These limits are due to the encoding method of tokens used by the tokenizer. Therefore, you cannot parse data larger than 64 GiB without chunking and fields longer than 16 MiB. Trying to read such a file will result in error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TableReader.jl/blob/35c61dd38d5a0d74dbfa92327881dd66df3a7cec/src/TableReader.jl#L52-L212">source</a></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">TableReader.jl</span></a></footer></article></body></html>
